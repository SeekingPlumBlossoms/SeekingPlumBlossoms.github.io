{"pages":[],"posts":[{"title":"Android手机支付宝客户端刷新session问题","text":"","link":"/2019/03/13/Android手机支付宝客户端刷新session问题/"},{"title":"Long.getLong()与Long.valueOf()的区别","text":"前言 最近在线上的日志出现了一些”java.lang.NullPointerException”,本着线上不应该出现这种空指针异常的问题,我去追踪了代码，记录下这个坑，防止后续继续踩坑. 前因 因为调用接口会有失败的可能，所以在调用接口失败后，需要休眠主线程，等待一段时间后，继续进行调用。 编写代码 需求不是很难,于是很快潇潇洒洒的写下的如下代码： 1234567 String times = \"300\";long timeL = Long.getLong(times);try { Thread.sleep(timeL);} catch (InterruptedException e) { e.printStackTrace();} 后续 就是这段简单的代码出现了错误：java.lang.NullPointerException 分析 getLong方法源码 1234567891011121314public static Long getLong(String nm, Long val) { String v = null; try { v = System.getProperty(nm); } catch (IllegalArgumentException | NullPointerException e) { } if (v != null) { try { return Long.decode(v); } catch (NumberFormatException e) { } } return val; } System.getProperty(nm)这个方法是获取系统的属性值 valueOf源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static long parseLong(String s, int radix) throws NumberFormatException { if (s == null) { throw new NumberFormatException(\"null\"); } if (radix &lt; Character.MIN_RADIX) { throw new NumberFormatException(\"radix \" + radix + \" less than Character.MIN_RADIX\"); } if (radix &gt; Character.MAX_RADIX) { throw new NumberFormatException(\"radix \" + radix + \" greater than Character.MAX_RADIX\"); } long result = 0; boolean negative = false; int i = 0, len = s.length(); long limit = -Long.MAX_VALUE; long multmin; int digit; if (len &gt; 0) { char firstChar = s.charAt(0); if (firstChar &lt; '0') { // Possible leading \"+\" or \"-\" if (firstChar == '-') { negative = true; limit = Long.MIN_VALUE; } else if (firstChar != '+') throw NumberFormatException.forInputString(s); if (len == 1) // Cannot have lone \"+\" or \"-\" throw NumberFormatException.forInputString(s); i++; } multmin = limit / radix; while (i &lt; len) { // Accumulating negatively avoids surprises near MAX_VALUE digit = Character.digit(s.charAt(i++),radix); if (digit &lt; 0) { throw NumberFormatException.forInputString(s); } if (result &lt; multmin) { throw NumberFormatException.forInputString(s); } result *= radix; if (result &lt; limit + digit) { throw NumberFormatException.forInputString(s); } result -= digit; } } else { throw NumberFormatException.forInputString(s); } return negative ? result : -result; } 总结 getLong方法是获取到系统属性之后,decode这个字符串返回了； valueOf 才是真正的装换方法 编写完成以后，需要进行单元测试，不要放过任何可疑的代码。","link":"/2019/01/23/Long-getLong-与Long-valueOf-的区别/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/06/03/hello-world/"},{"title":"okHttp报SSLPeerUnverifiedException异常解决方案","text":"前言最近在项目使用了okHttp进行网络通信，记录在使用okHttp对https进行请求是抛出SSLPeerUnverifiedException异常以及SSLHandshakeException异常问题的分析以及解决方式。 初始化OKHTTPClient客户端 请求参数的处理 12FormBody.Builder formBody = new FormBody.Builder();formBody.add(\"key\", value); url请求处理 12345Request request = new Request.Builder() .url(url) .addHeader(\"Content-Type\", \"application/x-www-form-urlencoded\") .post(formBody.build()) .build(); 返回结果的处理 123Call call = okHttpClient.newCall(request);Response response = call.execute();String bodyString = response.body().string(); SSLHandshakeException异常处理 此时直接发出https请求会返回以下错误 处理方法：对OKHTTPClient进行如下改造： 1234OkHttpClient okHttpClient = new OkHttpClient() .newBuilder() .sslSocketFactory(OkHttpsUtils.createSSLSocketFactory(), new TrustAllCerts()) .build(); 错误原因：其中sslSocketFactory传入了2个参数，进行本地证书的初始化赋值的动作，对于Https请求需要对本地证书进行初始化。 以下是createSSLSocketFactory源码以及TrustAllCerts源码 OkHttpsUtils.createSSLSocketFactory()： 12345678910111213public class OkHttpsUtils { public static SSLSocketFactory createSSLSocketFactory() { SSLSocketFactory ssfFactory = null; try { SSLContext sc = SSLContext.getInstance(\"TLS\"); sc.init(null,new TrustManager[]{new TrustAllCerts()}, new SecureRandom()); ssfFactory = sc.getSocketFactory(); }catch (Exception e){ e.printStackTrace(); } return ssfFactory; } } TrustAllCerts源码 12345678910111213141516public class TrustAllCerts implements X509TrustManager {@Overridepublic void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {}@Overridepublic void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {}@Overridepublic X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0];}} SSLPeerUnverifiedException异常处理 经过上述步骤后,继续请求会出现如下错误： 解决方法:对OKHTTPClient进行如下改造： 12345OkHttpClient okHttpClient = new OkHttpClient() .newBuilder() .sslSocketFactory(OkHttpsUtils.createSSLSocketFactory(), new TrustAllCerts()) .hostnameVerifier(new TrustAllHostnameVerifier()) .build(); 错误原因：验证对方的证书不通过 TrustAllHostnameVerifier源码 123456public class TrustAllHostnameVerifier implements HostnameVerifier { @Override public boolean verify(String s, SSLSession sslSession) { return true; }} 以上的方式是直接不验证对方的证书。具体okHttps内容可以参考这个文章https://blog.csdn.net/lmj623565791/article/details/48129405","link":"/2019/03/13/okHttp报SSLPeerUnverifiedException异常解决方案/"},{"title":"动态获取枚举值","text":"业务背景 依据不同的code获取不同的描述，所以需要查找了动态获取枚举的问题 枚举设计 12345678910111213141516171819202122232425public enum BizOptOrderTypeEnum { /**办理*/ CHECK_IN(0, \"办理\"), /**取消*/ CANCEL(1, \"取消\"), /**修改*/ UPDATE(2, \"修改\"); private Integer code; private String desc; BizOptOrderTypeEnum(Integer code, String desc) { this.code = code; this.desc = desc; } public Integer getCode() { return code; } public String getDesc() { return desc; } 动态获取枚举的方式 1234567long st = System.currentTimeMillis();int code= Enum.valueOf(BizOptOrderTypeEnum.class,\"CHECK_IN\").getCode();long ed=System.currentTimeMillis(); System.out.println(\"动态枚举获取参数为\"+code+\";耗时时间：\"+(ed-st)); int code1=BizOptOrderTypeEnum.CHECK_IN.getCode(); long sd=System.currentTimeMillis(); System.out.println(\"枚举获取参数为\"+code1+\";耗时时间：\"+(sd-ed)); 总结动态获取枚举的值需要预先知道有哪些key,设计的时候需要依据谋个固定的值获取到固定格式的KEY，如果没有这个key的话.会抛出异常：java.lang.IllegalArgumentException，需要注意.","link":"/2019/03/07/动态获取枚举值/"},{"title":"代码扫描工具","text":"前言作为一个程序员,需要对自己的代码进行CR,提前找到自己代码中的坏味道或者漏洞;先介绍如下几种代码扫描工具 sonar使用步骤1. 启动sona 地址：E:\\sonarqube-6.7.4\\bin 选择对应的环境执行 2. 登陆http://localhost:9000/ 3. 在工作空间执行 mvn sonar:sonar 4. 对比文档进行修改 FindBugs使用步骤1. 如图下载FindBUgs插件 使用说明邮件点击工程项目,然后点击FIndBugs执行扫描 【提示】 至此，findBugs安装完毕，但有个问题，在验证是否安装成功的时候发现，重新启动eclipse后并没有findBugs功能，经过查询分析，问题出在版本上，在线安装的是findBugs3.0的版本，这个版本对jdk的最低要求是jdk1.7。 P3C阿里插件 如上述步骤下载插件 使用方式和FindBugs一样","link":"/2018/11/22/代码扫描工具/"},{"title":"宾哥的技术之旅","text":"今天我宾哥就是要干翻在座的各位渣渣！ 一级标题二级标题三级标题 子曰：不搞个个人技术博客还能叫程序员？ 鲁迅说：子说的对我怎么斜了？ 我怎么黄了? @Component public class HbaseClient { @Bean public HbaseTemplate hbaseTemplate(@Value(&quot;${hbase.zookeeper.quorum}&quot;) String quorum, @Value(&quot;${hbase.zookeeper.port}&quot;) String port) { HbaseTemplate hbaseTemplate = new HbaseTemplate(); org.apache.hadoop.conf.Configuration conf = HBaseConfiguration.create(); conf.set(&quot;hbase.zookeeper.quorum&quot;, quorum); conf.set(&quot;hbase.zookeeper.port&quot;, port); hbaseTemplate.setConfiguration(conf); hbaseTemplate.setAutoFlush(true); return hbaseTemplate; } }","link":"/2018/06/05/宾哥的技术之旅/"},{"title":"設計模式之單例模式","text":"单例模式介绍单例模式（Single Pattern）:确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 单例模式的应用1.单例模式的优点 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁的创建、销毁时,而且创建或者销毁时性能又无法优化,单例模式的优势就非常明显。 由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要 比较多的资源时,如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象,然后用永久驻留内存的方式来解决(在java EE中采用单例模式时需要注意JVM垃圾回收机制)。 单例模式可以避免对资源的多重占用,例如一个写文件的动作,由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。 单例模式可以再系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。 2.单例模式的缺点 单例模式一般没有接口,扩展很困难,若要扩展,除了修改代码基本上没有第二种途径可以实现。因为接口对单例模式是没有任何意义的，它要求”自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。当然，在特殊情况下，单例模式可以实现接口、被继承等，需要在系统开发中根据环境判断。 单例模式对测试是不利的。在并发开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。 单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。 3.单例模式的使用场景 要求生成唯一序列号的环境； 在整个项目中需要一个共享访问点或者共享数据，例如一个web页面上的计数器，可以不用把每次舒心都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的； 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源; 需要定义大量的静态资源和静态方法(如工具类)的环境，可以采用单例模式（当然，也可以直接声明为static的方式） github示例:单例模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/04/設計模式之01單例模式/"},{"title":"設計模式之中介者模式","text":"中介者模式介绍 定义 中介者模式:用一个中介对象封装一系列的对象交互，中介者使个对象不需要显示地互相交互，从而使其耦合松散，而且可以独立地改变它们之间的交互。 Mediator抽象中介者角色 抽象中介者角色定义统一的接口，用于各角色之间的通信。 ConcreteMediator具体中介者角色 具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。 Colleague同事角色 每一个同事角色都知道中介者角色，而且与其他的同事角色的通信的时候，一定要通过中介者角色协作。每个同事类的行为分为2种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等。这种行为叫做自发行为(Self-Method),与其他的同事类或者中介者没有任何的依赖；第二种是必须依赖中介者才能完成的任务的行为，叫做依赖方法。 中介者模式的应用1.中介者模式的优点 中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同事也降低了类间的耦合。 2.中介者模式的缺点 中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越多。 3.中介者模式的使用场景 N个对象之间产生了相互依赖的关系(N&gt;2)。 多个对象有依赖关系，但是依赖的行为尚不能确定或者发生改变的可能，在这种情况下一般建议采用中介者模式，降低变更引起的风险扩散。 产品开发。把中介者模式应用到产品中，可以提升产品的性能和扩展性，但是对于项目开发就未必，因为项目是以交付投产为目标，而产品则是以稳定、高效、扩展为宗旨。 4.中介者模式案例 MVC框架 MVC框架：其中的C(Controller)就是一个中介者，叫做前端控制器，它的作用就是把M(Model，业务逻辑)和V(View,视图)隔离开，协调M和V协调工作，把M的运行结果和V代表的视图融合成一个前端可以展示的页面，减少M和V的依赖。 中介服务 媒体网关 机场调度中心 github示例:单例模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/05/設計模式之中介者模式/"},{"title":"設計模式之原型模式","text":"原型模式介绍 原型模式的定义 原型模式(PrototypePattern):用原型实例指定创建对象的种类，并且通过考呗这些原型创建新的对象。 原型模式的应用1.原型模式的优点 性能优良 原型模式是在内存二进制流的拷贝，要比直接new一个对象性能要好很多，特别是在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。 逃避构造函数的约束 这既是他的优点也是他的缺点，直接在内存中拷贝，构造函数不会被执行。优点就是减少了约束。 2.原型模式的使用场景 资源优化场景 类初始化需要消化非常多的资源，这个资源包括数据，硬件资源等。 性能和安全要求的场景 通过new产生一个对象需要非常繁琐的数据准备或者访问权限，则可以使用原型模式。 一个对象多个修改者的场景 一个对象需要提供给其他对象访问，而且各个调用者都可能需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 3.原型模式注意事项 构造函数不会被执行 浅拷贝和深拷贝 clone和final冲突 github示例: 原型模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/05/設計模式之原型模式/"},{"title":"設計模式之代理模式","text":"代理模式介绍 代理模式定义 代理模式(ProxyPattern):为其他对象提供一种代理以控制对这个对象的访问。 Subject抽象主体角色 抽象主题类可以是抽象类也可以是接口，是一个最普通的业务类型定义，无特殊要求。 RealSubkect具体主题角色 也叫做被委托的角色、被代理角色。它才是冤大头，是业务逻辑的具体执行者。 Proxy代理主题角色 *也叫做委托类、代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实的主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作。 代理模式的应用1.代理模式的优点 职责清晰 真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后去的代理完成一件事务，附带的结果就是编程简洁清晰。 高扩展性 具体主题角色是随时都会发生变化的，只要它实现了接口，甭管它如何变化，都逃不脱如来佛的手掌(接口)，那我们的代理类完全就可以再不做任何修改的情况下使用。 智能化 2.代理模式的扩展 普通代理 强制代理 动态代理 github示例:代理模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/05/設計模式之代理模式/"},{"title":"設計模式之命令模式","text":"命令模式介绍 定义 命令模式是一个高内聚的模式，将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。 角色 Receive接受者角色:该角色就是干活的角色，命令传递到这里是应该被执行的. Command命令角色：需要执行所有命令都在这里声明。 Invoker调用者角色：接受到命令，并执行命令。 命令模式的应用1.命令模式的优点 类间解耦 调用者角色与接受者角色之间没有任何依赖关系，调用者实现功能时只需要调用Command抽象类的execute方法就可以了，不需要了解到底哪个接受者执行了。 可扩展性 Command的子类可以非常容易的扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。 命令模式结合其他模式会更优秀 命令模式可以结合责任链模式，实现命令族解析，结合模板方法模式，则可以减少Command子类的膨胀问题。 2.命令模式的缺点 如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀的非常大，这个就需要读者在项目中慎重的考虑。 github示例:单例模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/06/設計模式之命令模式/"},{"title":"設計模式之工厂方法模式","text":"工厂方法模式介绍工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 工厂方法模式应用工厂方法模式的优点 良好的封装性，代码结构清晰。 工厂模式的扩展性非常优秀。在增加产品类的情况下，只要适当的修改具体的工厂类或者扩展一个工厂类就可以完成”拥抱变化”。 屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统的上层模块就不要发生变化，因为产品类的实例化工作是由工厂类负责的，一个产品对象具体由哪一个产品生产是由工厂类决定的。 工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流，也符合依赖倒置原则，只依赖产品类的抽象，当然也符合里式替换原则，使用产品子类替换产品父类，没有问题！ 工厂方法模式的使用场景 工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但是需要慎重的考虑是否需要增加一个工厂类进行管理，增加代码的复杂度。 需要灵活的、可扩展的框架时，可以考虑工厂模式。 工厂方法模式可以用在异构项目中，例如通过webservice与一个非Java的项目交互，虽然webservice号称是可以做到异构系统的同步化，但是在实际的开发中，还是会碰到很多问题，如类型问题、WSDL文件的支持问题，等等。 可以使用在测试驱动开发的框架下。例如，测试一个类A，就需要把与类A有关联关系的类B也同时产生出来，我们可以使用工厂方法模式把类B虚拟出来，避免类A与类B的耦合。目前由于JMock和EasyMock的诞生，该使用场景已经弱化了。 github示例:工厂方法模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/04/設計模式之工厂方法模式/"},{"title":"設計模式之抽象工厂模式","text":"抽象工厂模式介绍抽象工厂模式(Abstract Factory Pattern):为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。 抽象工厂模式的应用1.抽象工厂模式的优点 封装性，每个产品的实现类不是高层模块要关心的，它要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类，只要知道工厂类是谁，我就能创建出一个需要的对象，省时省力，优秀设计就应该如此。 产品族内的约束为非公开状态。具体的产品族内的约束是在工厂内实现的。 2.抽象工厂模式的缺点 抽象工厂模式的最大缺点就是产品族扩展非常困难。 3.抽象工厂模式的使用场景 一个对象族(或是一组没有任何关系的对象)都有相同的约束，则可以使用抽象工厂模式。 github示例:抽象工厂模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/04/設計模式之抽象工厂模式/"},{"title":"設計模式之建造者模式","text":"建造者模式介绍 定义 建造者模式(BuilderPattern):将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。 Product产品类： 通常是为了实现模板方法模式，也就是有模板方法的基本方法。 Builder抽象建造者 规范产品的组建，一般是由子类实现。 ConcreteBuilder具体建造者 实现抽象类定义的所有方法，并且返回一个组建好的对象。 Director导演类 负责安排已有的模块的顺序，然后告诉Builder开始建造。 建造者模式的应用建造者模式的优点 封装性 使用建造者模式可以使客户端不必知道产品内部的组成细节。 建造者独立，容易扩展 便于控制细节风险 由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模板产生任何的影响。 建造者模式的使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。 多个部件或者零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装对该对象的创建过程，这种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反涉及的最初目标。 github示例:建造者模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/05/設計模式之建造者模式/"},{"title":"設計模式之模板方法模式","text":"模板方法模式介紹模板方法模式(Template Method Pattern):定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定的步骤。 模板方法模式的应用1.模板方法模式的优点 封装不变部分，扩展可变部分。把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过类继承来继续扩展。 提取公共部分代码，便于维护。 行为由父类控制，子类实现。基本方法都是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。 2.模板方法模式的缺点 按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式缺颠倒了，抽象类定义了部分抽象方法，由子类实现，子类的执行结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。 3.模板方法模式的使用场景 多个子类有公有的方法，并且逻辑基本相同时。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则有各个子类实现。 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽象到父类中，然后通过钩子函数约束其行为。 github示例: 模板方法模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/04/設計模式之模板方法模式/"},{"title":"SpringBoot整合HBase","text":"前言SpringBoot整合HBase 废话不多说，开始步入正题！第一步，映入Maven依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-hadoop&lt;/artifactId&gt; &lt;version&gt;2.5.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 第二步，加入SpringBoot配置文件hbase.zookeeper.quorum=ip hbase.zookeeper.port=2181 第三步，引用HbaseTemplate,测试类使用方式@Autowired private HbaseTemplate hbaseTemplate; @Test public void contextLoads() { } @Test public void testPut() { hbaseTemplate.put(&quot;t&quot;, &quot;1&quot;, &quot;f&quot;, &quot;name&quot;, Bytes.toBytes(&quot;Alice&quot;)); hbaseTemplate.put(&quot;t&quot;, &quot;1&quot;, &quot;f&quot;, &quot;phone&quot;, Bytes.toBytes(&quot;15620974206&quot;)); } @Test public void testQuery(){ List&lt;String&gt; rows = hbaseTemplate.find(&quot;t&quot;, &quot;f&quot;, &quot;phone&quot;, new RowMapper&lt;String&gt;() { @Override public String mapRow(Result result, int i) throws Exception { return result.toString(); } }); System.out.println(JSONArray.toJSONString(rows)); List&lt;String&gt; rowli= hbaseTemplate.find(&quot;t&quot;, &quot;f&quot;, new RowMapper&lt;String&gt;() { @Override public String mapRow(Result result, int i) throws Exception { return result.toString(); } }); System.out.println(JSONArray.toJSONString(rowli)); } //依据表名，行号，列族，列名获取数据 @Test public void testCreateTable(){ if(hbaseTemplate.getConfiguration()==null){ System.out.println(&quot;为啥是空的呢&quot;); } String ls = hbaseTemplate.get(&quot;t&quot;, &quot;1&quot;,&quot;f&quot;, &quot;name&quot;, new RowMapper&lt;String&gt;() { @Override public String mapRow(Result result,int i)throws Exception{ List&lt;Cell&gt; cellList=result.listCells(); String res=&quot;&quot;; for(Cell cell:cellList){ res=Bytes.toString(cell.getValueArray(),cell.getValueOffset(),cell.getValueLength()); } return res; } }); System.out.println(ls); } 将使用原生的ConnectionFactory.createConnection进行调用HBASEimport com.hispeed.hbase.label.entity.R; import org.apache.hadoop.hbase.*; import org.apache.hadoop.hbase.client.*; import org.apache.hadoop.hbase.client.coprocessor.AggregationClient; import org.apache.hadoop.hbase.client.coprocessor.LongColumnInterpreter; import org.apache.hadoop.hbase.filter.FilterBase; import org.apache.hadoop.hbase.util.Bytes; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.data.hadoop.hbase.HbaseTemplate; import org.springframework.stereotype.Component; import java.io.IOException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; @Component public class Hbase { protected Logger logger = LoggerFactory.getLogger(getClass()); private Connection connection; public Hbase(HbaseTemplate hbaseTemplate){ try { connection = ConnectionFactory.createConnection(hbaseTemplate.getConfiguration()); } catch (IOException e) { e.printStackTrace(); } } public boolean createTable(String tableName, String familyName) { try { logger.info(&quot;检查表{}是否存在&quot;, tableName); if (connection.getAdmin().tableExists(TableName.valueOf(tableName))) { logger.info(&quot;表{}已存在&quot;, tableName); return true; } HTableDescriptor hTableDescriptor = new HTableDescriptor(TableName.valueOf(tableName)); HColumnDescriptor hColumnDescriptor = new HColumnDescriptor(familyName); hTableDescriptor.addFamily(hColumnDescriptor); connection.getAdmin().createTable(hTableDescriptor); logger.info(&quot;表{}已创建&quot;, tableName); } catch (IOException e) { e.printStackTrace(); return false; } return true; } public R insertData(String tableName, String familyName, String rowKey, Map&lt;String, String&gt; map) { try { if (!connection.getAdmin().tableExists(TableName.valueOf(tableName))) { logger.info(&quot;表{}不存在&quot;, tableName); return R.error(&quot;101&quot;, &quot;表不存在&quot;); } //HTable继承Table HTable hTable = (HTable) connection.getTable(TableName.valueOf(tableName)); Put put = new Put(rowKey.getBytes(), rowKey.length()); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) { KeyValue kv = new KeyValue(rowKey.getBytes(), 0, rowKey.getBytes().length, familyName.getBytes(), 0, familyName.getBytes().length, entry.getKey().getBytes(), 0, entry.getKey().getBytes().length, System.currentTimeMillis(), KeyValue.Type.Put, entry.getValue().getBytes(), 0, entry.getValue().getBytes().length); put.add(kv); } hTable.put(put); logger.info(&quot;插入成功&quot;); } catch (IOException e) { e.printStackTrace(); return R.error(&quot;999&quot;, &quot;插入HBase数据异常&quot;); } return R.ok(); } public &lt;T extends FilterBase&gt; List&lt;Map&lt;String,String &gt;&gt; queryResult(T filter, int count, String tableName,String familyName) { Scan scan = new Scan(); scan.setFilter(filter); try { if (!connection.getAdmin().tableExists(TableName.valueOf(tableName))) { logger.info(&quot;表{}不存在&quot;, tableName); return null; } HTable hTable = (HTable) connection.getTable(TableName.valueOf(tableName)); ResultScanner scanner=hTable.getScanner(scan); List&lt;Map&lt;String,String &gt;&gt; list=new ArrayList&lt;&gt;(); int ct=0; for (Result result : scanner) { Map&lt;String,String&gt; map=new HashMap(); List&lt;Cell&gt; cellList=result.listCells(); for(Cell cell : cellList){ String key= Bytes.toString(cell.getQualifierArray(),cell.getQualifierOffset(),cell.getQualifierLength()); String value= Bytes.toString(cell.getValueArray(),cell.getValueOffset(),cell.getValueLength()); map.put(key,value); } list.add(map); logger.info(&quot;查询数据的索引为&quot;+ct); if(list.size()&gt;=count){ break; } ct++; } scanner.close(); return list; } catch (IOException e) { e.printStackTrace(); } return null; } public &lt;T extends FilterBase&gt; long query(T filter ,String tableName,String familyName){ long rowCount = 0; Scan scan = new Scan(); scan.setFilter(filter); scan.addFamily(Bytes.toBytes(familyName)); AggregationClient ac = new AggregationClient(connection.getConfiguration()); try { rowCount = ac.rowCount(TableName.valueOf(tableName), new LongColumnInterpreter(), scan); }catch (Throwable throwable){ logger.info(throwable.getMessage(), throwable); } return rowCount; } public boolean isClose(){ try { connection.close(); } catch (IOException e) { e.printStackTrace(); return false; } return true; } } 宾曰：感谢踏雪大佬的指导，学如逆水行舟，不进则退","link":"/2018/06/20/SpringBoot整合HBase/"},{"title":"分布式全局唯一ID生成策略","text":"分布式系统的定义 分布式系统就是对外是统一的入口，对内是有很多计算机服务组装的系统。 为什么需要一个全局唯一主键 主要是用于某个记录的存储或者输出的时候，能找到唯一的记录，不能让数据错乱。数据库的唯一ID在单库单表的情况下可以使用，但是在使用分布式系统的时候，数据库的自增主键就不可以使用了.举个栗子：先有订单记录表1024张,如果使用数据库中的自增主键，那么就会有1024订单号相同的订单，这个肯定是不行的，所以需要分布式唯一的主键去确定订单号。 分布式唯一主键的需求 最基本也是最重要的：全局唯一，不可重复 有一定的连续性:数据库存储使用的是B-TREE数据结构存储，我们要尽量保证ID是有序的增长 主键上需要能看到数据的记录位置 分布式唯一主键生成的方式1.UUID生成唯一主键1UUID.randomUUID() 优点 使用方便，性能高，无网络或者IO消耗. 缺点 无法作为DB主键使用，但是可以对于分布式链路追踪ID可以适用 长度太长：36位 2.使用Redis生成唯一的主键 使用redis的原子incr操作，保证实现主键递增； 优点 不依赖数据库，性能高 主键自然增长，能均匀分布到数据库中 缺点 需要引入redis并且需要维护自增的主键key,自增到什么长度数据合适(需要考虑) 对于redis性能有要求 3.数据库自增ID机制 依据插入数据库返回的数据主键进行计算出主键,即是需要逻辑的索引库，库的作用就是获取序列。 优点 简单有序。充分利用数据库的自增 缺点 生成ID需要读写数据库 对数据库的性能保障有要求 4.SnowFlake雪花算法 优点 简单高效,不依赖外部组件 按照时间有序递增 12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号 缺点 依赖机器的时钟，如果时钟回拨，会造成ID重复 分布式环境下，机器时钟不是同步，会出现ID不是递增的情况 附带SnowFlake雪花算法(Java)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * Twitter_Snowflake&lt;br&gt; * SnowFlake的结构如下(每部分用-分开):&lt;br&gt; * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt; * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt; * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。 * 41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt; * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt; * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt; * 加起来刚好64位，为一个Long型。&lt;br&gt; * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高， * 经测试，SnowFlake每秒能够产生26万ID左右。 */public class SnowflakeIdWorker { // ==============================Fields=========================================== /** 开始时间截 (2015-01-01) */ private final long twepoch = 1420041600000L; /** 机器id所占的位数 */ private final long workerIdBits = 5L; /** 数据标识id所占的位数 */ private final long datacenterIdBits = 5L; /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); /** 支持的最大数据标识id，结果是31 */ private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); /** 序列在id中占的位数 */ private final long sequenceBits = 12L; /** 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** 数据标识id向左移17位(12+5) */ private final long datacenterIdShift = sequenceBits + workerIdBits; /** 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /** 工作机器ID(0~31) */ private long workerId; /** 数据中心ID(0~31) */ private long datacenterId; /** 毫秒内序列(0~4095) */ private long sequence = 0L; /** 上次生成ID的时间截 */ private long lastTimestamp = -1L; //==============================Constructors===================================== /** * 构造函数 * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnowflakeIdWorker(long workerId, long datacenterId) { if (workerId &gt; maxWorkerId || workerId &lt; 0) { throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId)); } if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) { throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", maxDatacenterId)); } this.workerId = workerId; this.datacenterId = datacenterId; } // ==============================Methods========================================== /** * 获得下一个ID (该方法是线程安全的) * @return SnowflakeId */ public synchronized long nextId() { long timestamp = timeGen(); //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp &lt; lastTimestamp) { throw new RuntimeException( String.format(\"Clock moved backwards. Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp)); } //如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) { sequence = (sequence + 1) &amp; sequenceMask; //毫秒内序列溢出 if (sequence == 0) { //阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); } } //时间戳改变，毫秒内序列重置 else { sequence = 0L; } //上次生成ID的时间截 lastTimestamp = timestamp; //移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) // | (datacenterId &lt;&lt; datacenterIdShift) // | (workerId &lt;&lt; workerIdShift) // | sequence; } /** * 阻塞到下一个毫秒，直到获得新的时间戳 * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) { long timestamp = timeGen(); while (timestamp &lt;= lastTimestamp) { timestamp = timeGen(); } return timestamp; } /** * 返回以毫秒为单位的当前时间 * @return 当前时间(毫秒) */ protected long timeGen() { return System.currentTimeMillis(); } //==============================Test============================================= /** 测试 */ public static void main(String[] args) { SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0); for (int i = 0; i &lt; 1000; i++) { long id = idWorker.nextId(); System.out.println(Long.toBinaryString(id)); System.out.println(id); } }}","link":"/2019/03/07/分布式全局唯一ID生成策略/"}],"tags":[{"name":"事故","slug":"事故","link":"/tags/事故/"},{"name":"okHttp","slug":"okHttp","link":"/tags/okHttp/"},{"name":"java随笔","slug":"java随笔","link":"/tags/java随笔/"},{"name":"排查工具","slug":"排查工具","link":"/tags/排查工具/"},{"name":"技术心得","slug":"技术心得","link":"/tags/技术心得/"},{"name":"設計模式","slug":"設計模式","link":"/tags/設計模式/"},{"name":"分布式","slug":"分布式","link":"/tags/分布式/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"}]}
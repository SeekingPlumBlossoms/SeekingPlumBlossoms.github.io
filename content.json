{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/06/03/hello-world/"},{"title":"設計模式之單例模式","text":"单例模式介绍单例模式（Single Pattern）:确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 单例模式的应用1.单例模式的优点 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁的创建、销毁时,而且创建或者销毁时性能又无法优化,单例模式的优势就非常明显。 由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要 比较多的资源时,如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象,然后用永久驻留内存的方式来解决(在java EE中采用单例模式时需要注意JVM垃圾回收机制)。 单例模式可以避免对资源的多重占用,例如一个写文件的动作,由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。 单例模式可以再系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。 2.单例模式的缺点 单例模式一般没有接口,扩展很困难,若要扩展,除了修改代码基本上没有第二种途径可以实现。因为接口对单例模式是没有任何意义的，它要求”自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。当然，在特殊情况下，单例模式可以实现接口、被继承等，需要在系统开发中根据环境判断。 单例模式对测试是不利的。在并发开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。 单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。 3.单例模式的使用场景 要求生成唯一序列号的环境； 在整个项目中需要一个共享访问点或者共享数据，例如一个web页面上的计数器，可以不用把每次舒心都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的； 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源; 需要定义大量的静态资源和静态方法(如工具类)的环境，可以采用单例模式（当然，也可以直接声明为static的方式） github示例:单例模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/04/設計模式之01單例模式/"},{"title":"代码扫描工具","text":"前言作为一个程序员,需要对自己的代码进行CR,提前找到自己代码中的坏味道或者漏洞;先介绍如下几种代码扫描工具 sonar使用步骤1. 启动sona 地址：E:\\sonarqube-6.7.4\\bin 选择对应的环境执行 2. 登陆http://localhost:9000/ 3. 在工作空间执行 mvn sonar:sonar 4. 对比文档进行修改 FindBugs使用步骤1. 如图下载FindBUgs插件 使用说明邮件点击工程项目,然后点击FIndBugs执行扫描 【提示】 至此，findBugs安装完毕，但有个问题，在验证是否安装成功的时候发现，重新启动eclipse后并没有findBugs功能，经过查询分析，问题出在版本上，在线安装的是findBugs3.0的版本，这个版本对jdk的最低要求是jdk1.7。 P3C阿里插件 如上述步骤下载插件 使用方式和FindBugs一样","link":"/2018/11/22/代码扫描工具/"},{"title":"宾哥的技术之旅","text":"今天我宾哥就是要干翻在座的各位渣渣！ 一级标题二级标题三级标题 子曰：不搞个个人技术博客还能叫程序员？ 鲁迅说：子说的对我怎么斜了？ 我怎么黄了? @Component public class HbaseClient { @Bean public HbaseTemplate hbaseTemplate(@Value(&quot;${hbase.zookeeper.quorum}&quot;) String quorum, @Value(&quot;${hbase.zookeeper.port}&quot;) String port) { HbaseTemplate hbaseTemplate = new HbaseTemplate(); org.apache.hadoop.conf.Configuration conf = HBaseConfiguration.create(); conf.set(&quot;hbase.zookeeper.quorum&quot;, quorum); conf.set(&quot;hbase.zookeeper.port&quot;, port); hbaseTemplate.setConfiguration(conf); hbaseTemplate.setAutoFlush(true); return hbaseTemplate; } }","link":"/2018/06/05/宾哥的技术之旅/"},{"title":"設計模式之中介者模式","text":"中介者模式介绍 定义 中介者模式:用一个中介对象封装一系列的对象交互，中介者使个对象不需要显示地互相交互，从而使其耦合松散，而且可以独立地改变它们之间的交互。 Mediator抽象中介者角色 抽象中介者角色定义统一的接口，用于各角色之间的通信。 ConcreteMediator具体中介者角色 具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。 Colleague同事角色 每一个同事角色都知道中介者角色，而且与其他的同事角色的通信的时候，一定要通过中介者角色协作。每个同事类的行为分为2种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等。这种行为叫做自发行为(Self-Method),与其他的同事类或者中介者没有任何的依赖；第二种是必须依赖中介者才能完成的任务的行为，叫做依赖方法。 中介者模式的应用1.中介者模式的优点 中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同事也降低了类间的耦合。 2.中介者模式的缺点 中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越多。 3.中介者模式的使用场景 N个对象之间产生了相互依赖的关系(N&gt;2)。 多个对象有依赖关系，但是依赖的行为尚不能确定或者发生改变的可能，在这种情况下一般建议采用中介者模式，降低变更引起的风险扩散。 产品开发。把中介者模式应用到产品中，可以提升产品的性能和扩展性，但是对于项目开发就未必，因为项目是以交付投产为目标，而产品则是以稳定、高效、扩展为宗旨。 4.中介者模式案例 MVC框架 MVC框架：其中的C(Controller)就是一个中介者，叫做前端控制器，它的作用就是把M(Model，业务逻辑)和V(View,视图)隔离开，协调M和V协调工作，把M的运行结果和V代表的视图融合成一个前端可以展示的页面，减少M和V的依赖。 中介服务 媒体网关 机场调度中心 github示例:单例模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/05/設計模式之中介者模式/"},{"title":"設計模式之代理模式","text":"代理模式介绍 代理模式定义 代理模式(ProxyPattern):为其他对象提供一种代理以控制对这个对象的访问。 Subject抽象主体角色 抽象主题类可以是抽象类也可以是接口，是一个最普通的业务类型定义，无特殊要求。 RealSubkect具体主题角色 也叫做被委托的角色、被代理角色。它才是冤大头，是业务逻辑的具体执行者。 Proxy代理主题角色 *也叫做委托类、代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实的主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作。 代理模式的应用1.代理模式的优点 职责清晰 真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后去的代理完成一件事务，附带的结果就是编程简洁清晰。 高扩展性 具体主题角色是随时都会发生变化的，只要它实现了接口，甭管它如何变化，都逃不脱如来佛的手掌(接口)，那我们的代理类完全就可以再不做任何修改的情况下使用。 智能化 2.代理模式的扩展 普通代理 强制代理 动态代理 github示例:代理模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/05/設計模式之代理模式/"},{"title":"設計模式之原型模式","text":"原型模式介绍 原型模式的定义 原型模式(PrototypePattern):用原型实例指定创建对象的种类，并且通过考呗这些原型创建新的对象。 原型模式的应用1.原型模式的优点 性能优良 原型模式是在内存二进制流的拷贝，要比直接new一个对象性能要好很多，特别是在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。 逃避构造函数的约束 这既是他的优点也是他的缺点，直接在内存中拷贝，构造函数不会被执行。优点就是减少了约束。 2.原型模式的使用场景 资源优化场景 类初始化需要消化非常多的资源，这个资源包括数据，硬件资源等。 性能和安全要求的场景 通过new产生一个对象需要非常繁琐的数据准备或者访问权限，则可以使用原型模式。 一个对象多个修改者的场景 一个对象需要提供给其他对象访问，而且各个调用者都可能需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 3.原型模式注意事项 构造函数不会被执行 浅拷贝和深拷贝 clone和final冲突 github示例: 原型模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/05/設計模式之原型模式/"},{"title":"設計模式之命令模式","text":"命令模式介绍 定义 命令模式是一个高内聚的模式，将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。 角色 Receive接受者角色:该角色就是干活的角色，命令传递到这里是应该被执行的. Command命令角色：需要执行所有命令都在这里声明。 Invoker调用者角色：接受到命令，并执行命令。 命令模式的应用1.命令模式的优点 类间解耦 调用者角色与接受者角色之间没有任何依赖关系，调用者实现功能时只需要调用Command抽象类的execute方法就可以了，不需要了解到底哪个接受者执行了。 可扩展性 Command的子类可以非常容易的扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。 命令模式结合其他模式会更优秀 命令模式可以结合责任链模式，实现命令族解析，结合模板方法模式，则可以减少Command子类的膨胀问题。 2.命令模式的缺点 如果有N个命令，问题就出来了，Command的子类就可不是几个，而是N个，这个类膨胀的非常大，这个就需要读者在项目中慎重的考虑。 github示例:单例模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/06/設計模式之命令模式/"},{"title":"設計模式之工厂方法模式","text":"工厂方法模式介绍工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 工厂方法模式应用工厂方法模式的优点 良好的封装性，代码结构清晰。 工厂模式的扩展性非常优秀。在增加产品类的情况下，只要适当的修改具体的工厂类或者扩展一个工厂类就可以完成”拥抱变化”。 屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统的上层模块就不要发生变化，因为产品类的实例化工作是由工厂类负责的，一个产品对象具体由哪一个产品生产是由工厂类决定的。 工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流，也符合依赖倒置原则，只依赖产品类的抽象，当然也符合里式替换原则，使用产品子类替换产品父类，没有问题！ 工厂方法模式的使用场景 工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但是需要慎重的考虑是否需要增加一个工厂类进行管理，增加代码的复杂度。 需要灵活的、可扩展的框架时，可以考虑工厂模式。 工厂方法模式可以用在异构项目中，例如通过webservice与一个非Java的项目交互，虽然webservice号称是可以做到异构系统的同步化，但是在实际的开发中，还是会碰到很多问题，如类型问题、WSDL文件的支持问题，等等。 可以使用在测试驱动开发的框架下。例如，测试一个类A，就需要把与类A有关联关系的类B也同时产生出来，我们可以使用工厂方法模式把类B虚拟出来，避免类A与类B的耦合。目前由于JMock和EasyMock的诞生，该使用场景已经弱化了。 github示例:工厂方法模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/04/設計模式之工厂方法模式/"},{"title":"設計模式之建造者模式","text":"建造者模式介绍 定义 建造者模式(BuilderPattern):将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。 Product产品类： 通常是为了实现模板方法模式，也就是有模板方法的基本方法。 Builder抽象建造者 规范产品的组建，一般是由子类实现。 ConcreteBuilder具体建造者 实现抽象类定义的所有方法，并且返回一个组建好的对象。 Director导演类 负责安排已有的模块的顺序，然后告诉Builder开始建造。 建造者模式的应用建造者模式的优点 封装性 使用建造者模式可以使客户端不必知道产品内部的组成细节。 建造者独立，容易扩展 便于控制细节风险 由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模板产生任何的影响。 建造者模式的使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。 多个部件或者零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装对该对象的创建过程，这种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反涉及的最初目标。 github示例:建造者模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/05/設計模式之建造者模式/"},{"title":"設計模式之抽象工厂模式","text":"抽象工厂模式介绍抽象工厂模式(Abstract Factory Pattern):为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。 抽象工厂模式的应用1.抽象工厂模式的优点 封装性，每个产品的实现类不是高层模块要关心的，它要关心的是什么？是接口，是抽象，它不关心对象是如何创建出来，这由谁负责呢？工厂类，只要知道工厂类是谁，我就能创建出一个需要的对象，省时省力，优秀设计就应该如此。 产品族内的约束为非公开状态。具体的产品族内的约束是在工厂内实现的。 2.抽象工厂模式的缺点 抽象工厂模式的最大缺点就是产品族扩展非常困难。 3.抽象工厂模式的使用场景 一个对象族(或是一组没有任何关系的对象)都有相同的约束，则可以使用抽象工厂模式。 github示例:抽象工厂模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/04/設計模式之抽象工厂模式/"},{"title":"設計模式之模板方法模式","text":"模板方法模式介紹模板方法模式(Template Method Pattern):定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定的步骤。 模板方法模式的应用1.模板方法模式的优点 封装不变部分，扩展可变部分。把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过类继承来继续扩展。 提取公共部分代码，便于维护。 行为由父类控制，子类实现。基本方法都是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。 2.模板方法模式的缺点 按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式缺颠倒了，抽象类定义了部分抽象方法，由子类实现，子类的执行结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。 3.模板方法模式的使用场景 多个子类有公有的方法，并且逻辑基本相同时。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则有各个子类实现。 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽象到父类中，然后通过钩子函数约束其行为。 github示例: 模板方法模式 友情链接：(大佬)SnoWalker’s Blog","link":"/2018/12/04/設計模式之模板方法模式/"},{"title":"SpringBoot整合HBase","text":"前言SpringBoot整合HBase 废话不多说，开始步入正题！第一步，映入Maven依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-hadoop&lt;/artifactId&gt; &lt;version&gt;2.5.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 第二步，加入SpringBoot配置文件hbase.zookeeper.quorum=ip hbase.zookeeper.port=2181 第三步，引用HbaseTemplate,测试类使用方式@Autowired private HbaseTemplate hbaseTemplate; @Test public void contextLoads() { } @Test public void testPut() { hbaseTemplate.put(&quot;t&quot;, &quot;1&quot;, &quot;f&quot;, &quot;name&quot;, Bytes.toBytes(&quot;Alice&quot;)); hbaseTemplate.put(&quot;t&quot;, &quot;1&quot;, &quot;f&quot;, &quot;phone&quot;, Bytes.toBytes(&quot;15620974206&quot;)); } @Test public void testQuery(){ List&lt;String&gt; rows = hbaseTemplate.find(&quot;t&quot;, &quot;f&quot;, &quot;phone&quot;, new RowMapper&lt;String&gt;() { @Override public String mapRow(Result result, int i) throws Exception { return result.toString(); } }); System.out.println(JSONArray.toJSONString(rows)); List&lt;String&gt; rowli= hbaseTemplate.find(&quot;t&quot;, &quot;f&quot;, new RowMapper&lt;String&gt;() { @Override public String mapRow(Result result, int i) throws Exception { return result.toString(); } }); System.out.println(JSONArray.toJSONString(rowli)); } //依据表名，行号，列族，列名获取数据 @Test public void testCreateTable(){ if(hbaseTemplate.getConfiguration()==null){ System.out.println(&quot;为啥是空的呢&quot;); } String ls = hbaseTemplate.get(&quot;t&quot;, &quot;1&quot;,&quot;f&quot;, &quot;name&quot;, new RowMapper&lt;String&gt;() { @Override public String mapRow(Result result,int i)throws Exception{ List&lt;Cell&gt; cellList=result.listCells(); String res=&quot;&quot;; for(Cell cell:cellList){ res=Bytes.toString(cell.getValueArray(),cell.getValueOffset(),cell.getValueLength()); } return res; } }); System.out.println(ls); } 将使用原生的ConnectionFactory.createConnection进行调用HBASEimport com.hispeed.hbase.label.entity.R; import org.apache.hadoop.hbase.*; import org.apache.hadoop.hbase.client.*; import org.apache.hadoop.hbase.client.coprocessor.AggregationClient; import org.apache.hadoop.hbase.client.coprocessor.LongColumnInterpreter; import org.apache.hadoop.hbase.filter.FilterBase; import org.apache.hadoop.hbase.util.Bytes; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.data.hadoop.hbase.HbaseTemplate; import org.springframework.stereotype.Component; import java.io.IOException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; @Component public class Hbase { protected Logger logger = LoggerFactory.getLogger(getClass()); private Connection connection; public Hbase(HbaseTemplate hbaseTemplate){ try { connection = ConnectionFactory.createConnection(hbaseTemplate.getConfiguration()); } catch (IOException e) { e.printStackTrace(); } } public boolean createTable(String tableName, String familyName) { try { logger.info(&quot;检查表{}是否存在&quot;, tableName); if (connection.getAdmin().tableExists(TableName.valueOf(tableName))) { logger.info(&quot;表{}已存在&quot;, tableName); return true; } HTableDescriptor hTableDescriptor = new HTableDescriptor(TableName.valueOf(tableName)); HColumnDescriptor hColumnDescriptor = new HColumnDescriptor(familyName); hTableDescriptor.addFamily(hColumnDescriptor); connection.getAdmin().createTable(hTableDescriptor); logger.info(&quot;表{}已创建&quot;, tableName); } catch (IOException e) { e.printStackTrace(); return false; } return true; } public R insertData(String tableName, String familyName, String rowKey, Map&lt;String, String&gt; map) { try { if (!connection.getAdmin().tableExists(TableName.valueOf(tableName))) { logger.info(&quot;表{}不存在&quot;, tableName); return R.error(&quot;101&quot;, &quot;表不存在&quot;); } //HTable继承Table HTable hTable = (HTable) connection.getTable(TableName.valueOf(tableName)); Put put = new Put(rowKey.getBytes(), rowKey.length()); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) { KeyValue kv = new KeyValue(rowKey.getBytes(), 0, rowKey.getBytes().length, familyName.getBytes(), 0, familyName.getBytes().length, entry.getKey().getBytes(), 0, entry.getKey().getBytes().length, System.currentTimeMillis(), KeyValue.Type.Put, entry.getValue().getBytes(), 0, entry.getValue().getBytes().length); put.add(kv); } hTable.put(put); logger.info(&quot;插入成功&quot;); } catch (IOException e) { e.printStackTrace(); return R.error(&quot;999&quot;, &quot;插入HBase数据异常&quot;); } return R.ok(); } public &lt;T extends FilterBase&gt; List&lt;Map&lt;String,String &gt;&gt; queryResult(T filter, int count, String tableName,String familyName) { Scan scan = new Scan(); scan.setFilter(filter); try { if (!connection.getAdmin().tableExists(TableName.valueOf(tableName))) { logger.info(&quot;表{}不存在&quot;, tableName); return null; } HTable hTable = (HTable) connection.getTable(TableName.valueOf(tableName)); ResultScanner scanner=hTable.getScanner(scan); List&lt;Map&lt;String,String &gt;&gt; list=new ArrayList&lt;&gt;(); int ct=0; for (Result result : scanner) { Map&lt;String,String&gt; map=new HashMap(); List&lt;Cell&gt; cellList=result.listCells(); for(Cell cell : cellList){ String key= Bytes.toString(cell.getQualifierArray(),cell.getQualifierOffset(),cell.getQualifierLength()); String value= Bytes.toString(cell.getValueArray(),cell.getValueOffset(),cell.getValueLength()); map.put(key,value); } list.add(map); logger.info(&quot;查询数据的索引为&quot;+ct); if(list.size()&gt;=count){ break; } ct++; } scanner.close(); return list; } catch (IOException e) { e.printStackTrace(); } return null; } public &lt;T extends FilterBase&gt; long query(T filter ,String tableName,String familyName){ long rowCount = 0; Scan scan = new Scan(); scan.setFilter(filter); scan.addFamily(Bytes.toBytes(familyName)); AggregationClient ac = new AggregationClient(connection.getConfiguration()); try { rowCount = ac.rowCount(TableName.valueOf(tableName), new LongColumnInterpreter(), scan); }catch (Throwable throwable){ logger.info(throwable.getMessage(), throwable); } return rowCount; } public boolean isClose(){ try { connection.close(); } catch (IOException e) { e.printStackTrace(); return false; } return true; } } 宾曰：感谢踏雪大佬的指导，学如逆水行舟，不进则退","link":"/2018/06/20/SpringBoot整合HBase/"}],"tags":[{"name":"設計模式","slug":"設計模式","link":"/tags/設計模式/"},{"name":"排查工具","slug":"排查工具","link":"/tags/排查工具/"},{"name":"技术心得","slug":"技术心得","link":"/tags/技术心得/"}],"categories":[]}